<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Шпаргалка по HTML5/CSS/JS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anek+Latin:wght@600&display=swap" rel="stylesheet">  
    <link rel="stylesheet" href="./styles.css">  
    <style>
        table {
            width: 100%;
        }
        
        .first-td {
            width: 15%;
        }
        .first-td-tx {
            width: 27%;
        }

        .third-td {
            width: 25%;
            
        }
        .third-td-tx {
            width: 45%;
            text-align: center;
        }

        th {
            background-color: #b9b9b9;
        }

        p {
            margin: 10px;
            text-indent: 10px;            
        }

        body {
            font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 16px;
            background-color: rgb(243, 241, 233);
        }

        .link,
        h1 span {
            opacity: 0.3;
            color: rgb(44, 182, 26);           
        }

        h1 span {
            font-size: 19px;
            color: black;
        }

        .link:hover {
            opacity: 1;
            color: rgb(168, 9, 9);
        }

        .specificity {
            font-size: 25px;
           font-family: 'Anek Latin', sans-serif;
           color: rgb(165, 161, 161);

        }
        .specificity .one {
           color: #000;
        }

        .arrow {
            position: fixed;
            bottom: 20px;
            right: 50px;                      
        }

        .arrow { 
            font-size: 14px;
            padding-top: 5px;
            border: 3px solid rgb(255, 255, 255);
            border-radius: 20px;
            background-color: rgb(0, 0, 0);
            display: inline-block;           
            color: rgb(255, 255, 255);
            opacity: 0.4;
            text-decoration: none;
        }

        .arrow:hover {
            opacity: 1;
        }

        .icon {
            fill: currentColor;
            stroke: currentColor;
            
        }
        .arrow p {            
            text-indent: 0;
        }
        #top {
            text-align: center;
        }        
   </style>
</head>
<body  id="top">    
    <h1>JavaScript (JS)</h1></><br><br>    
    <table border="1">
        <thead>
            <tr>
                <th colspan="3"><h2>Основні поняття</h2></th>              
            </tr>              
        </thead>
        <tbody>
            <tr>
                <td class="first-td"><p><b>Суворий режим<br></b></p></td>
                <td><p>Нова можливість у специфікації ECMAScript 5, яка дозволяє переводити скрипт у режим повної відповідності сучасному
                     стандарту. Це запобігає певним помилкам, як-от використання небезпечних і застарілих конструкцій. Для того, щоб
                      перевести скрипт в суворий режим, достатньо зазначити директиву на початку js-файлу.</p>
                </td>
                <td class="third-td">"use strict";</td>           
            </tr>
            <tr>
                <td class="first-td"><p><b>Інструкція<br>(statement)</b></p></td>
                <td><p>пов'язаний набір слів і символів із синтаксису мови, які об'єднуються 
                    з метою вираження однієї ідеї, однієї інструкції для машини. Інструкції в JavaScript завершуються крапкою з комою.</p>
                </td> 
                <td class="third-td">a = b * 2;</td>                            
            </tr>
            <tr>
                <td class="first-td"><p><b>Вираз<br>(expression)</b></p></td>
                <td><p>посилання на змінну або значення, або на набір змінних і значень в поєднанні з операторами.</p>
                </td>
                <td class="third-td">[ [a] = [ [b] * [2] ] ]</td>           
            </tr>            
            <tr>
                <td class="first-td"><p><b>Інтерфейс<br></b></p></td>
                <td><p>набір властивостей і методів сутності, доступних для використання у вихідному коді.</p>
                </td>
                <td class="third-td"></td>           
            </tr>
            <tr>
                <td class="first-td"><p><b>Властивість<br></b></p></td>
                <td><p> у всіх даних є якісь властивості (кількісні, якісні, т.д.), наприклад у рядка є властивість його довжини.
                     Синтаксис звернення до властивості дуже простий - через крапку.</p>
                </td>
                <td class="third-td">XXXXXX.ім`я_властивості</td>           
            </tr>
            <tr>
                <td class="first-td"><p><b>Метод<br></b></p></td>
                <td><p>у даних є свої заздалегідь визначені методи (виклики якоїсь дії, активна операція), наприклад, можна додати
                     або видалити елементи з колекції, перевести рядок в інший регістр тощо. Синтаксис виклику метода дуже схожий
                      на звернення до властивості, але в кінці додається пара круглих дужок.</p>
                </td>
                <td class="third-td">XXXXXX.ім`я_методу()</td>           
            </tr>
            
        </tbody>
    </table>
    <br>
    <table border="1">
        <thead>
            <tr>
                <th colspan="3"><h2>Змінні і типи</h2></th>              
            </tr>              
        </thead>
        <tbody>
            <tr>
                <td class="first-td" colspan="3" style="background-color: #c4c4c4"><p><b>Змінні використовуються для зберігання даних і складаються із ідентифікатора (імені) 
                    і області в пам'яті, де зберігається їх значення.</b></p></td>
                         
            </tr>
            <tr>
                <td class="first-td"><p><b>Ідентифікатор</b></p></td>
                
                <td colspan="2"> це ім'я змінної, функції або класу. Складається з одного або декількох символів у наступному форматі:<br><br>
                  - Першим символом повинна бути літера a-z або A-Z, символ підкреслення _ або знак долара $.<br>
                  - Інші символи можуть бути літерами a-z, A-Z, цифрами 0-9, підкресленнями _ і знаками долара $.<br>
                  - Ідентифікатори чуттєві до регістру. Це означає, що змінні user, usEr і User - різні.<br><br>
                
                Ім'я змінної повинно бути зрозумілим. Використання camelCase-нотації для ідентифікаторів - це стандарт. Перше слово пишеться малими літерами,
                 а кожне наступне починається з великої. Наприклад, user, greetUser, getUserData, isActive, activeGuestCount, totalWorkerSalary. <br><br> 
                <b>НЕ ВИКОРИСТОВУВАТИ</b> в якості імен <a href="https://textbook.edu.goit.global/javascript-yk5evp/v2/uk/docs/lesson-01/variables/#%D0%BA%D0%BB%D1%8E%D1%87%D0%BE%D0%B2%D1%96-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" >ключові зарезервовані слова.</a></td>           
            </tr>
            <tr>
                <td class="first-td"><p><b>Оголошення змінних</b></p></td>
                <td colspan="2"><p>Оголошення змінних починається з ключових слів (після яких слідує ідентифікатор-ім'я): <br><br> <b>const</b> - змінна повинна бути одразу 
                    ініціалізована значенням, після чого її не можна перевизначити. <br><br> <b>let</b> -  змінна може бути не ініціалізована одразу, у подальшому
                     її можна буде перевизначити необхідну кількість раз (присвоїти нове значення). <br><br><u>Невизначена (undefined)</u> - це змінна, яка була оголошена ключовим словом let, але не ініціалізована значенням. 
                     За замовчуванням їй присвоюється початкове значення undefined. <br><br><u>Неоголошена (undeclared або not defined)</u>  - це змінна, яка не була оголошена в доступній області видимості. Спроба звернутися
                      до змінної до її оголошення призведе до помилки. Наприклад, щоб прочитати або змінити її значення.
                    </td>                       
            </tr>
            <tr>
                <td class="first-td"><p><b>Константи</b></p></td>
                <td colspan="2"><p>Імена КОНСТАНТ - змінних, значення яких не змінюється ніколи впродовж роботи всього скрипту, як правило, записуються у форматі UPPER_SNAKE_CASE.</p>
                </td>                       
            </tr>
            <tr>
                <td class="first-td" colspan="3" style="background-color: #c4c4c4"><p><b>Змінна може зберігати значення різних типів даних. Існуть наступні типи даних:</b></p></td>                          
            </tr>
            <tr>
                <td colspan="3"><p><b><u>Примітивні типи:</u></b></p></td>                                       
            </tr>
            <tr>
                <td class="first-td"><p><b>Number</b></p></td>
                <td colspan="2"><p>цілі числа і числа з плаваючою комою (крапкою)</p>
                </td>                          
            </tr>
            <tr>
                <td class="first-td"><p><b>BigInt</b></p></td>
                <td colspan="2"><p>для представлення цілих чисел довільної довжини. Значення з типом BigInt створюється через додавання n у кінець цілого числа</p>
                </td>                          
            </tr>
              <tr>
                <td class="first-td"><p><b>String</b></p></td>
                <td colspan="2"><p>рядки, послідовність з нуля або більше символів. Рядок починається і закінчується одинарними або подвійними лапками</p>
                </td>                          
            </tr>
              <tr>
                <td class="first-td"><p><b>Boolean</b></p></td>
                <td colspan="2"><p>логічний тип даних, прапорці стану. Всього два значення: <b>true</b> і <b>false</b></p>
                </td>                          
            </tr>
              <tr>
                <td class="first-td"><p><b>null</b></p></td>
                <td colspan="2"><p>особливе значення, яке по суті означає <b>'ніщо'</b>. Використовується в тих ситуаціях, коли необхідно явно вказати порожнечу.
                     Наприклад, якщо користувач нічого не вибрав, то можна сказати що значення <b>null</b>.</p>
                </td>                          
            </tr> 
            <tr>
                <td class="first-td"><p><b>undefined</b></p></td>
                <td colspan="2"><p>ще одне спеціальне значення. За замовчуванням, коли змінна оголошується, але не ініціалізується, її значення не визначено, їй присвоюється <b>'undefined'</b></p>
                </td>                          
            </tr>
            <tr>
                <td class="first-td"><p><b>Symbol</b></p></td>
                <td colspan="2"><p>використовується для створення унікальних ідентифікаторів в об’єктах</p>
                </td>                          
            </tr>
             <tr>
                <td colspan="3"><p><b><u>Складний (особливий) тип:</u></b></p></td>                                       
            </tr>
            <tr>
                <td class="first-td"><p><b>Object</b></p></td>
                <td colspan="2"><p>зберігають в собі колекції даних і більш складні структури (інші об'єкти, функції, масиви тощо).</b></p>
                </td>                          
            </tr>
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"> Для отримання типу значення змінної використовується оператор <b>typeof</b>, він повертає на місце свого виклику
                     тип значення змінної, вказаного після нього - рядок, в якому вказано тип. 
                </td>
            </tr>
            <tr>
                <td class="first-td" colspan="3" style="background-color: #c4c4c4"><p><b>Взаємодія з користувачем. Базові операції введення/виведення:</b></p></td>                          
            </tr>
            <tr>
            <td class="first-td"><p><b>console.log()</b></p></td>
                <td colspan="2"><p>виводить результати роботи скрипту в рядках секції Консоль (інструменти розробника)</p></td>                          
            </tr>
              <tr>
                <td class="first-td"><p><b>alert()</b></p></td>
                <td colspan="2"><p>виводить модальне вікно, текст якого відповідає значенню змінної (або літерала), яку передаємо в дужках.</p></td>                          
            </tr>
            <tr>
                <td class="first-td"><p><b>confirm()</b></p></td>
                <td colspan="2"><p>виводить модальне вікно з повідомленням, і дві кнопки, Ok і Cancel. Натискаючи на Ok,
                     результатом будет true, натискаючи на Cancel - повертається false.</b></p></td>                          
            </tr>
            <tr>
                <td class="first-td"><p><b>prompt()</b></p></td>
                <td colspan="2"><p>виводить модальне вікно з полем введення і кнопками Ok і Cancel.
                    Натискаючи на Ok, результатом буде те, що ввів користувач, у випадку Cancel - повертається null.</b></p></td>                          
            </tr>
             <tr>
                <td class="first-td" colspan="3" style="background-color: #c4c4c4"><p><b>Основні оператори:</b></p></td>                          
            </tr>
            <tr>
            <td class="first-td"><p><b>Математичні оператори</b></p></td>
                <td colspan="2"><p>+  (додавання) <br><br> - (віднімання)<br><br> * (множення)<br><br> / (ділення)<br><br>  % (залишок від ділення)</p></td>                          
            </tr>
              <tr>
                <td class="first-td"><p><b>Оператори порівняння та рівності</b></p></td>
                <td colspan="2"><p> >  < (більше/менше)<br><br> >=  <= (більше-рівне/менше-рівне)<br><br> == (рівність)<br><br> != (нерівність)<br><br> === (сувора рівність)<br><br> !== (сувора нерівність)</p> </td>                          
            </tr>
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"> «Несуворі» оператори рівності/нерівності (== і !=) виконують
                     перетворення типів порівнюваних значень у число. Тому краще використовувати суворі оператори (=== і !==).
                </td>
            </tr>            
            <tr>
                <td class="first-td"><p><b>Логічні оператори</b></p></td>
                <td colspan="2"><p><b>&&</b> - логічне "І" приводить всі операнди до буля і повертає значення одного з них. Лівий операнд - якщо його можна привести
                     до false, і правий - в інших випадках. Тобто, логічне «І» зупиняється на хибному і повертає те, на чому зупинилось, або останній операнд<br><br>
                    <b>||</b> - логічне "АБО"приводить всі операнди до буля і повертає значення одного з них. Лівий операнд - якщо його можна привести до true,
                     і правий - в інших випадках. Тобто, логічне «АБО» зупиняється на правді і повертає те, на чому зупинилося або останній операнд.<br><br>
                    <b>!</b> - логічне "НЕ" приводить операнд до буля, якщо необхідно, а потім робить інверсію - змінює його на протилежне значення: true -> false або false -> true.</p></td>                          
            </tr>           
        </tbody> 
        <!-- РОЗГАЛУЖЕННЯ ТА ЦИКЛИ -->   
        <thead>
            <tr>
                <th colspan="3"><p><h1>Розгалуження та цикли</h1></p></th>              
            </tr>                          
        </thead>
        <tbody>
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"> <b>Розгалуження</b> використовуються для виконання різноманітного коду, залежно від умови.
                     Принцип роботи простий - результат умови приводиться до буля <b>"true"</b> або <b>"false"</b>, після чого потік програми спрямовується в ту або іншу гілку.
                </td>
            </tr>  
            <tr>
                <td class="first-td-tx"><p><b>Інструкція "if"</b><br><br></p></td>
                <td><p>if (умова) {<br> інструкція "if"<br>}</p></td>
                <td class="third-td-tx" ><p></p>Вхідні дані, які приводяться до буля, називаються умовою. Умова ставиться після оператора if
                    в круглих дужках. Якщо умова приводиться до <u>true</u>, то виконується код у фігурних дужках тіла <b>if</b> (інструкція).
                     Якщо умова приводиться до <u>false</u>, код у фігурних дужках буде пропущений <br><br><u><b>Іншими словами інструкція "if" перевіряє ОДНУ умову,
                      в залежності від значення true/false якої виконується/не виконується ОДИН набір команд.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Інструкція "if...else"</b><br><br></p></td>
                <td><p>if (умова) {<br> інструкція "if"<br>} else { <br>інструкція "else"}</p></td>
                <td class="third-td-tx" ><p></p>Розширює синтаксис інструкція "if": якщо умова в дужках після оператора if приводиться до <u>true</u>, то виконується
                     код у фігурних дужках тіла <b>if</b> (інструкція  "if"). Якщо умова приводиться до <u>false</u>, виконається код у фігурних дужках після 
                     оператора else (інструкція  "else"). <br><br><u><b>Іншими словами інструкція "if...else" перевіряє ОДНУ умову,
                      в залежності від значення true/false якої виконується ОДИН з ДВОХ наборів команд.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Інструкція "else...if"</b><br><br></p></td>
                <td><p>if (умова 1) {<br> перша інструкція "if"<br>} else if</b> (умова 2) {<br> друга інструкція "if"<br>} else if</b> (умова 3) {<br> третя інструкція "if"<br>} else { <br> інструкція "else"}</p></td>
                <td class="third-td-tx" ><p></p>Блок "else...if" дозволяє додати після else ще один оператор "if" або "if...else" з умовою. Таких ланок може бути необмежене число. В кінці ланцюжка може
                     бути класичний блок else, який виконається лише у тому випадку, якщо жодна умова не приведеться до true. При першому true перевірки припиняться і виконається лише один сценарій,
                      який відповідає цьому true. Тому, такий запис варто читати як: шукаю перший збіг умови, ігнорую все інше.<br><br><u><b>Іншими словами інструкція "else...if" перевіряє ПЕРШУ умову:
                         якщо вона "true" - виконується перший набір команд, якщо "false" - переходим до перевірки ДРУГОЇ умови: якщо "true" - виконується другий набір команд, якщо "false" - переходим до перевірки 
                         ТРЕТЬОЇ умови і т.д.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Тернарний оператор</b><br><br></p></td>
                <td><p> const XXXXX = (умова) ? 'перше значення (умова "true")' : 'друге значення (умова "false")'</p></td>
                <td class="third-td-tx" ><p></p>використовується у якості синтаксично <u>коротшої заміни інструкції if...else</u>, коли одній і тій самій змінній необхідно
                     присвоїти різні значення за умовою. Значення обчисленого виразу повертається у якості результату роботи тернарного оператора. Тернарний оператор
                      повинен використовуватися у простих операціях присвоєння або повернення.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Інструкція "switch"</b><br><br></p></td>
                <td><p> switch (XXXXX) {<br>  case значення 1:<br>    інструкції;<br>    break;<br><br>   case значення 2:<br>    інструкції;<br>    break;<br><br> case значення 3:<br>    інструкції;<br> 
                       break;<br><br>  default:<br>    інструкції;}</p></td>
                <td class="third-td-tx" ><p></p>використовується у якості <u>«плоскішого» синтаксису для заміни інструкції if...else</u>. Його синтаксис складається із блоку зі змінною switch(XXXXX)
                     - що потрібно порівняти і набору окремих значень [case "значення"] - з чим потрібно порівняти. Для порівняння використовується оператор суворої рівності === (тобто, не можна порівняти
                      більше або менше, лише рівність). <br> Значення змінної в блоці switch(XXXXX) - рядок або число, яке порівнюється щодо суворої рівності з усіма значеннями в блоках case значення
                       по черзі, зверху вниз. Оператор <u>break</u> в кінці кожного блоку case необхідний, щоб перервати подальші перевірки і одразу перейти до коду за switch у тому випадку, коли перевірка
                        рівності повернула "true". <br> Якщо жодного збігу значень не відбулося, необхідно виконати код за замовчуванням, як і в блоці else для інструкції if...else. Для цього, після усіх блоків 
                        case додається блок default. Оператор break після блоку default не потрібен, тому що це вже остання операція, яка буде виконана в switch і управління буде передано коду після нього.
                     </b></u></p></td>           
            </tr>
            
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"><b>Цикл</b> - керуюча конструкція у високорівневих мовах програмування, призначена для організації багаторазового виконання набору інструкцій.
                    Основні визначення у циклах: <br> <u>Тіло циклу</u> - послідовність інструкцій, призначена для багаторазового виконання. <br> <u>Ітерація</u> - одноразове виконання тіла циклу.  <br> <u>Умова
                         виходу</u> - вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться. <br><u>Лічильник</u> - змінна, що зберігає поточний номер ітерації. Цикл не обов'язково
                          містить лічильник, і він не повинен бути один, умова виходу з циклу може залежати від декількох змінних, що змінюються в циклі.
                </td>
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "while"</b><br><br></p></td>
                <td><p>while (condition) { <br>  <span style="color: #f79c41"> код, тіло циклу (statement)</span> <br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>передумовою</u>  — цикл, який виконується, доки правдива якась умова (condition), зазначена до його початку. Ця умова перед кожною ітерацією циклу (statement),
                     тому тіло може не виконатися жодного разу, якщо умова від самого початку - хибна.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "do...while"</b><br><br></p></td>
                <td><p>do { <br> <span style="color: #f79c41"> код, тіло циклу (statement)</span> <br> } while (condition)</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>постумовою</u> - цикл, в якому умова перевіряється після виконання тіла циклу. З цього випливає, що тіло завжди виконується
                     хоча б один раз.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for"</b><br><br></p></td>
                <td><p>for (initialization; condition; post-expression) {<br> <span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>лічильником</u> - цикл, в якому певна змінна змінює своє значення із заданого початкового до кінцевого значення з деяким кроком,
                     і для кожного значення цієї змінної тіло циклу виконується один раз. В більшості процедурних мов програмування реалізується конструкцією for, в якій зазначається
                      лічильник, необхідна кількість ітерацій і крок, з яким змінюється лічильник.Алгоритм виконання циклу for:<br><br> - Ініціалізація (initialization) - виконується один
                       раз до початку циклу. Використовується для створення змінної-лічильника і зазначення її початкового значення. <br> - Умова (condition) - вираз, що оцінюється перед 
                       кожною ітерацією (повторенням) циклу. Тіло циклу виконується тільки тоді, коли вираз приводиться до true. Цикл завершується, якщо значення буде false. <br>  Тіло (statements)
                        - набір інструкцій для виконання на кожному повторенні. Виконується, якщо вираз умови приводиться до true. <br> Пост-вираз (post-expression) - виконується в кінці
                         кожного повторення циклу, до перевірки умови. Використовується для оновлення змінної-лічильника.<br><br> Змінні-лічильники, за традицією, називаються літерами i, j і k.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for...of"</b><br><br></p></td>
                <td><p>for (const <b>variable</b> of <b>iterable</b>) {<br>  <span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл без <u>лічильника</u> - оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки. Тіло циклу буде виконуватися
                     для значення кожного елемента. Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації. Основні визначення циклу for...of:<br><br> - variable —
                      змінна, яка буде зберігати значення елемента на кожній ітерації. <br><br> - iterable — колекція, яка містить ітерабельні (що можна порахувати) елементи, наприклад масив. -  <br>  
                         <br><br></b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for...in"</b><br><br></p></td>
                <td><p>for (key in object) {<br><span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx"><p>Цикл для перебирання ключів об'єкта <b>object</b>. <br>Змінна key доступна тільки в тілі циклу. На кожній ітерації в неї буде записано
                     значення ключа (ім'я) властивості. Для того, щоб отримати значення властивості з таким ключем (ім'ям), використовується синтаксис квадратних дужок: <b>object[key]</b><br><br>
                     Оператор in, який використовується в циклі for...in, не робить різниці між власними та невласними властивостями об'єкта. Ця особливість заважає, оскільки ми завжди хочемо перебрати
                      тільки власні властивості. Для того, щоб дізнатись, чи містить об'єкт власну властивість, використовується метод hasOwnProperty(key), який повертає true або false. Саме через цю особливість 
                      for...in  тепер майже не використовується, замість нього використовують for...of.</p>
                </td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "forEach"</b><br><br></p></td>
                <td><p><span style="color: #1a00dd">[масив]</span>.forEach(function callback(element, index, array) {<br>  <span style="color: #f79c41">
                    код, тіло циклу (statement)</span><br>});</p></td>
                <td class="third-td-tx"><p>Метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією
                     даних. Цикл: <br><br>- Поелементо перебирає масив. <br> - Викликає колбек-функцію для кожного елемента масиву. <br> - Нічого не повертає.
                      <br><br>Аргументи колбек-функції - це значення поточного елемента element, його індекс index і власне вихідний масив array.
                       Можна оголошувати тільки необхідні параметри, найчастіше - це елемент, головне не забувати про їх порядок.</p>
                </td>           
            </tr>
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"> Для додаткового керування циклом існує два оператори  <b>"break"</b>  та  <b>"continue"</b>: <br><br><b>"break"</b> - повністю припиняє виконання циклу
                     і передає управління на рядок після його тіла.<br><br>  <b>"continue"</b> - перериває не увесь цикл, а тільки виконання поточної ітерації. Його використовують, якщо зрозуміло, що на поточній 
                     ітерації циклу більше немає що робити або взагалі не потрібно нічого робити, і час переходити до наступної ітерації. 
                </td>
            </tr>
            <!-- Основні операції та методи -->
            <!-- ЧИСЛА -->
        <thead>
            <tr>
                <th colspan="3"><p><h2>Тип даних <b>Number</b></h2></p></th>              
            </tr>                          
        </thead>
        <tbody>
            <tr>
                <td style="padding: 10px;" colspan="3">Основні методи для роботи з даними типу <b>Number</b> (власні методи та методи вбудованого класу <b>Math</b>):
                </td>
            </tr>  
            <tr>
                <td class="first-td-tx"><p><b>Number(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>функція приведення значення до числа</p></td>
                <td class="third-td-tx" ><p>Більшість арифметичних операцій і математичних функцій перетворюють значення у число автоматично.
                    Функція Number(value) використовується для явного приведення зазначеного значення до числа.</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.isNaN(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx" ><p>перевіряє, чи вказане значення є NaN. Метод відповідає на запитання "Це <b>Not A Number</b>?" і повертає:
                    <b>true</b> - якщо значення value = NaN;  <b>false</b> - якщо значення value = не NaN</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.isInteger(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx" ><p>перевіряє, чи вказане значення є цілим числом. Результат - логічне значення <b>true</b>, якщо дане значення
                     є цілим числом; інакше  - <b>false</b>.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.parseInt(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx" ><p> метод парсингу (зчитування) цілого числа з рядка: зчитує рядок символ за символом, доки це можливо (аналізує рядковий аргумент), і повертає ціле число. У разі виникнення
                     помилки повертається підсумкове число. Якщо помилка з першого ж символу - поверне NaN</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.parseFloat(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx" ><p>метод парсингу (зчитування) дробового числа з рядка: зчитує рядок символ за символом, доки це можливо (аналізує рядковий аргумент), і повертає дробове число. У разі виникнення
                     помилки повертається підсумкове число. Якщо помилка з першого ж символу - поверне NaN</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.toFixed(<span style="color: #dd8c00">number of decimal places</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx" ><p>метод для приведення дробового числа: "заокруглює" десятковий дріб до потрібної кількості знаків після коми.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Number.toExponential(<span style="color: #dd8c00">number of decimal places</span>)</b></p></td>
                <td><p>власний метод</p></td>
                <td class="third-td-tx"><p>метод для приведення числа в експоненціальний запис з заокругленням основи (мантиси) до заданої кількості цифр після коми: <span style="background-color: #c8c8c8">number = 12345678;  number.toExponential(3);</span>  приведеться до 1.235e+7 </p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.floor(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx" ><p>повертає найбільше ціле число, яке менше або дорівнює зазначеному числу</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.ceil(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx" ><p>повертає найменше ціле число, яке більше або дорівнює зазначеному числу</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.round(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx" ><p>округлення числа до найближчого цілого</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.max(<span style="color: #dd8c00">number1, number2, number3, ...</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає найбільше число з набору</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.min(<span style="color: #dd8c00">number1, number2, number3, ...</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає найменше число з набору</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b> Math.pow(<span style="color: #dd8c00">base, exponent</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>піднесення "base" до степеня "exponent"</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b>Math.random() <br><span style="color: #7e7d7d">(Math.random() * (10 - 1) + 1))</span></b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає псевдовипадкове число в діапазоні [0, 1] <br><span style="color: #7e7d7d">(псевдовипадкове число від 1 до 10)</span></p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b> Math.sqrt(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає квадратний корінь числа number</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b> Math.trunc(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає цілу частину числа, видаляючи повністю усю дробову частину (напр.: 73,072 => 73)</p>
                </td>          
            </tr>
             <tr>
                <td class="first-td-tx"><p><b> Math.abs(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>повертає абсолютне значення числа або виразу (значення по модулю)</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b> Math.PI</b></p></td>
                <td><p>метод вбудованого класу Math</p></td>
                <td class="third-td-tx"><p>представляє відношення довжини кола до його діаметра (число "ПІ")</p>
                </td>          
            </tr>
            <!-- РЯДКИ -->
            <thead>           
                <tr>
                    <th colspan="3"><p><h2>Тип даних <b>String</b></h2></p></th>              
                </tr>                          
            </thead>       
            <tr>
                <td style="padding: 10px;" colspan="3">Основні властивості та методи для роботи з даними типу <b>String</b>:
                </td>
            </tr>            
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.length</b></p></td>
                <td><p>вбудована властивість рядка</p></td>
                <td class="third-td-tx"><p>вказує довжину рядка, тобто кількість його символів</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">string</span>.toLowerCase()</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок у "нижньому" регістрі, не змінюючи оригінальний рядок.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">string</span>.toUpperCase()</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок у "ВЕРХНЬОМУ" регістрі, не змінюючи оригінальний рядок.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.indexOf(<span style="color: #dd8c00">substring</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає індекс (позицію елемента в рядку), на якому знаходиться перший збіг підрядка (substring) або -1
                    , якщо  нічого не знайдено (заданого підрядка немає у рядку).</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.includes(<span style="color: #dd8c00">substring</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>перевіряє, чи міститься підрядок в рядку, повертає <b>true</b>, якщо міститься, і <b>false</b> - якщо ні. Регістр
                     символів в рядку і підрядку має значення, оскільки, наприклад, літера "a" не дорівнює літері "А".</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.endsWith(<span style="color: #dd8c00">substring</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>дозволяє визначити, чи завершується рядок символами (підрядком), зазначеними в дужках, повертаючи <b>true</b> або <b>false</b></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.replace(<span style="color: #dd8c00">substring1, substring2</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок, в якому ПЕРШИЙ збіг підрядка (substring1) буде замінений на вказане значення (substring2).</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.replaceAll(<span style="color: #dd8c00">substring1, substring2</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок, в якому УСІ збіги підрядка (substring1) будуть замінені на вказане значення (substring2).</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.slice(<span style="color: #dd8c00">startIndex, endIndex</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>використовується для створення копії частини або всього рядка: він робить копію елементів рядка від <b>startIndex</b> і до
                     (але не включно) <b>endIndex</b> та повертає новий рядок, не змінюючи оригінал.</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string1</span>.concat(<span style="color: #dd8c00">string2</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок - результат об’єднання викликаючого рядка  з рядком в дужках (послідовність важлива)</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.repeat(<span style="color: #dd8c00">number</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>повертає новий рядок, який містить вказану кількість (number) копій початкового рядка (string), об’єднаних разом</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.trim()</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>видаляє пробіли з обох кінців рядка та повертає новий рядок, не змінюючи оригінальний рядок. Щоб повернути новий рядок
                     із обрізаним пробілом лише з одного кінця, використовуйте trimStart()або trimEnd()</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">string</span>.split(<span style="color: #dd8c00">delimiter</span>)</b></p></td>
                <td><p>метод рядка</p></td>
                <td class="third-td-tx"><p>перетворює рядок в масив, «розбиваючи» його роздільником <b>delimiter</b>. Якщо роздільник - це порожній рядок (""),
                     то створиться масив окремих символів. Роздільником може бути один або декілька символів.</p></td>           
            </tr>
            <!-- МАСИВИ -->
            <thead>           
                <tr>
                    <th colspan="3"><p><h2>Масиви <b>Array</b></h2></p></th>              
                </tr>                          
            </thead>       
            <tr>
                <td style="padding: 10px;" colspan="3">Масив - структура даних для зберігання і маніпулювання колекцією індексованих значень.
                     Використовується для зберігання впорядкованих колекцій даних, наприклад, списку курортів, товарів, клієнтів в готелі тощо. <br>
                     Масив оголошується і береться у квадратні дужки [] - літералом масиву. Всередині дужок кожен елемент масиву розділяється комою.  <br><br>
                      Основні властивості та методи для роботи з масивами <b>Array</b>:
                </td>
            </tr>            
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">array</span>[index]</b></p></td>
                <td><p>звертання до елементів масиву</p></td>
                <td class="third-td-tx"><p>синтаксис квадратних дужок - використовується для доступу до значення елемента масиву.
                      Між іменем змінної, що зберігає масив, і квадратними дужками не повинно бути пробілу. На відміну від рядків, які можна лише зчитувати, елементи
                       масиву можна змінювати, звернувшись до них за індексом і переприсвоївши інше значення.</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color: #dd8c00">array</span>.length</b></p></td>
                <td><p>властивість масиву</p></td>
                <td class="third-td-tx"><p>вказує довжину масиву, тобто кількість елементів які містить масив. Це динамічна величина,
                     яка змінюється автоматично під час додавання або видалення елементів</p></td>           
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.join(<span style="color: #dd8c00">delimiter</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>об'єднує елементи масиву в рядок, який і повертає. У рядку елементи будуть розділені символом або групою символів, 
                    зазначених в <b>delimiter</b>. Тобто ця операція протилежна методу рядків split(delimiter).</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.indexOf(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>повертає перший індекс, під яким елемент зі значенням <b>value</b> був знайдений в масиві, або число -1, якщо
                     такий елемент відсутній</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.includes(<span style="color: #dd8c00">value</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>перевіряє, чи містить масив елемент зі значенням <b>value</b> і повертає <b>true</b> або <b>false</b> відповідно. Застосування цього
                     методу корисне в ситуаціях, коли необхідно перевірити, чи є елемент в масиві і не важлива його позиція (не потрібен індекс)</p>
                </td>          
            </tr>
           <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.push(<span style="color: #dd8c00">element1, element2, ...</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>добавляє елемент (елементи) в кінець масиву. Повертає довжину масиву після додавання елементів. Змінює довжину масиву</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.pop()</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>видаляє останній елемент масиву і повертає видалений елемент. Якщо масив порожній, метод повертає <b>undefined</b>. Змінює довжину масиву </p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.unshift(<span style="color: #dd8c00">element1, element2, ...</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>добавляє елемент (елементи) на початок масиву. Повертає довжину масиву після додавання елементів. Змінює довжину масиву </p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.shift()</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>видаляє перший елемент масиву і повертає видалений елемент. Якщо масив порожній, метод повертає <b>undefined</b>. Змінює довжину масиву</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.slice(<span style="color: #dd8c00">begin, end</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>повертає новий масив, що містить копію частини вихідного масиву, не змінюючи його. Копія створюється з індексу
                     <b>begin</b> і до індексу (але не включно), <b>end</b> вихідного масиву.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array1</span>.concat(<span style="color: #dd8c00">array2, array3, ...</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>повертає новий масив, що об'єднує два або більше масивів в один. Порядок аргументів методу впливає на порядок елементів нового масиву</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.slpice(<span style="color: #dd8c00">start, number</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>видалення елементів з масиву: <b>start</b> - індекс елементу, з якого потрібно почати видалення; <b>number</b> - кількість елементів, які необхідно
                     видалити. Змінює вихідний масив і повертає масив, що містить видалені елементи</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.slpice(<span style="color: #dd8c00">start,</span> 0,<span style="color: #dd8c00"> element1, element2, ...</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>додавання елементів в масив: <b>start</b> - індекс, з якого потрібно почати додавання нових елементів; 0 - вказівка не видаляти жодних елементів,
                     <b>element1, element2, ...</b> - нові елементи, які потрібно додат. Змінює вихідний масив і повертає пустий масив [] (масив, що містить видалені елементи)</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.slpice(<span style="color: #dd8c00">start, number, element1, element2, ...</span>)</b></p></td>
                <td><p>метод масиву</p></td>
                <td class="third-td-tx"><p>заміна елементів в масиві: <b>start</b> - індекс елементу, з якого потрібно почати заміну елементів; <b>number</b> - кількість елементів, які необхідно замінити;
                     <b>element1, element2, ...</b> - нові елементи, якими потрібно замінити старі. Змінює вихідний масив і повертає масив, що містить замінені елементи</p>
                </td>          
            </tr>
            <tr>
                <td style="padding: 10px;" colspan="3">Перебираючі методи масиву - методи масивів, що прийшли з функціональних мов. Більшість з них - це чисті функції. Вони створюють новий масив, заповнюють його,
                     застосовуючи до значення кожного елемента зазначену <b>колбек-функцію</b>, після чого повертають цей новий масив. Усі перебираючі методи масивів мають схожий синтаксис - вихідний масив
                      <b>array</b>, виклик методу <b>method</b> і 
                     колбек-функція <b>callback</b> як аргумент методу: <b> array.method(callback)</b>
                </td>
            </tr>     
           <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.map(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>map</b>(callback) використовується для трансформації масиву. Він викликає колбек-функцію для кожного елемента вихідного масиву, а результат її роботи записує
                     у новий масив, який і буде результатом виконання методу: <br>-- не змінює оригінальний масив; <br> - поелементо перебирає оригінальний масив; <br> - результат роботи колбек-функції
                      записується у новий масив; <br>- повертає новий масив однакової довжини.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.flatMap(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>flatMap</b>(callback) аналогічний методу map(), але відміність від map() у тому, що новий масив «розгладжується» на глибину, що дорівнює одній вкладеності</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.filter(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>filter</b>(callback) використовується для єдиної операції - фільтрації масиву, тобто, коли необхідно вибрати більше одного елемента з колекції за
                     певним критерієм: <br>- не змінює оригінальний масив; <br>- поелементо перебирає оригінальний масив; <br>- повертає новий масив, у який додає елементи, які задовольняють
                      умови колбек-функції ( true - елемент додається, false - не додається); <br>- якщо жоден елемент не задовольнив умову, повертає порожній масив.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.find(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>find</b>(callback) дозволяє знайти і повернути перший елемент, який задовільняє умову, після чого перебирання масиву припиняється: <br>- не
                     змінює оригінальний масив; <br>- поелементо перебирає оригінальний масив; <br>- повертає перший елемент, який задовільняє умови колбек-функції (колбек повертає true); <br>- якщо жоден елемент не
                      задовольнив умову, повертає undefined.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.findIndex(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>findIndex</b>(callback) повертає індекс першого елемента, який задовільняє умову, після чого перебирання масиву припиняється - це сучасна заміна методу indexOf().
                     Дозволяє виконувати пошук за складнішими умовами, ніж просто рівність. Використовується як для пошуку у масиві примітивів, так і в масиві об'єктів: <br>- не
                     змінює оригінальний масив; <br>- поелементо перебирає оригінальний масив; <br>- повертає індекс першого елемента, який задовільняє умови колбек-функції (колбек повертає true); <br>- якщо жоден
                      елемент не задовольняє умову, тобто для всіх елементів колбек повернув false, метод повертає -1.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.every(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>every</b>(callback) перевіряє, чи проходять всі елементи масиву тест колбек-функції. Повертає true або false: <br>- не
                     змінює оригінальний масив; <br>- поелементо перебирає оригінальний масив; <br>- повертає true, якщо всі елементи масиву задовольняють умову; <br>- повертає false, якщо хоча б
                      один елемент масиву не задовольняє умову;<br>- перебирання масиву припиняється, якщо колбек повертає false.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx"><p><b><span style="color:#dd8c00">array</span>.some(<span style="color: #5dc266">(element, index, array) =>{ }</span>)</b></p></td>
                <td><p>перебираючий метод масиву <br><br>element - елемент масиву (обов'язковий) <br><span style="color:#a7a6a6">index - індекс елемента (необов'язковий)</span> <br><span style="color:#a7a6a6">
                    array - вихідний масив(необов'язковий)</span></p></td>
                <td class="third-td-tx"><p>Метод <b>some</b>(callback) перевіряє, чи проходить хоча б один елемент масиву тест колбек-функції. Повертає true або false: <br>- не
                     змінює оригінальний масив; <br>- поелементо перебирає оригінальний масив; <br>- повертає true, якщо хоча б один елемент масиву задовольняє умову; <br>- повертає false, якщо жоден елемент
                      масиву не задовольняє умову;<br>- перебирання масиву припиняється, якщо колбек повертає true.</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.sort()</b></p></td>
                <td><p>перебираючий метод масиву</p></td>
                <td class="third-td-tx"><p>Метод <b>sort</b>(callback) сортує елементи масиву: <br>- сортує і змінює вихідний
                     масив; <br>- повертає змінений масив, тобто посилання на відсортований вихідний; <br>- за замовчуванням сортує за зростанням; <br>- сортування відбувається шляхом приведення
                      значень до рядка і порівняння порядкових номерів у таблиці Unicode</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.sort(<span style="color: #5dc266">(a, b) => a - b </span>)</b></p><br>
                <p><b><span style="color:#dd8c00">array</span>.sort(<span style="color: #5dc266">(a, b) =>  b - a </span>)</b></p>
                <td><p>перебираючий метод масиву </p></td>
                <td class="third-td-tx"><p> - сортування чисел за зростанням;<br><br><br> - сортування чисел за спаданням;</p>
                </td>          
            </tr>
            <tr>
                <td class="first-td-tx" style="background-color: #ffd8d8"><p><b><span style="color:#dd8c00">array</span>.sort(<span style="color: #5dc266">(a, b) => a.localeCompare(b) </span>)</b></p><br>
                <p><b><span style="color:#dd8c00">array</span>.sort(<span style="color: #5dc266">(a, b) => b.localeCompare(a) </span>)</b></p>
                <td><p>перебираючий метод масиву </p></td>
                <td class="third-td-tx"><p> - сортування рядків за зростанням;<br><br><br> - сортування рядків за спаданням;</p>
                </td>          
            </tr>
           






            
           
            
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"><b>Цикл</b> - керуюча конструкція у високорівневих мовах програмування, призначена для організації багаторазового виконання набору інструкцій.
                    Основні визначення у циклах: <br> <u>Тіло циклу</u> - послідовність інструкцій, призначена для багаторазового виконання. <br> <u>Ітерація</u> - одноразове виконання тіла циклу.  <br> <u>Умова
                         виходу</u> - вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться. <br><u>Лічильник</u> - змінна, що зберігає поточний номер ітерації. Цикл не обов'язково
                          містить лічильник, і він не повинен бути один, умова виходу з циклу може залежати від декількох змінних, що змінюються в циклі.
                </td>
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "while"</b><br><br></p></td>
                <td><p>while (condition) { <br>  <span style="color: #f79c41"> код, тіло циклу (statement)</span> <br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>передумовою</u>  — цикл, який виконується, доки правдива якась умова (condition), зазначена до його початку. Ця умова перед кожною ітерацією циклу (statement),
                     тому тіло може не виконатися жодного разу, якщо умова від самого початку - хибна.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "do...while"</b><br><br></p></td>
                <td><p>do { <br> <span style="color: #f79c41"> код, тіло циклу (statement)</span> <br> } while (condition)</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>постумовою</u> - цикл, в якому умова перевіряється після виконання тіла циклу. З цього випливає, що тіло завжди виконується
                     хоча б один раз.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for"</b><br><br></p></td>
                <td><p>for (initialization; condition; post-expression) {<br> <span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл з <u>лічильником</u> - цикл, в якому певна змінна змінює своє значення із заданого початкового до кінцевого значення з деяким кроком,
                     і для кожного значення цієї змінної тіло циклу виконується один раз. В більшості процедурних мов програмування реалізується конструкцією for, в якій зазначається
                      лічильник, необхідна кількість ітерацій і крок, з яким змінюється лічильник.Алгоритм виконання циклу for:<br><br> - Ініціалізація (initialization) - виконується один
                       раз до початку циклу. Використовується для створення змінної-лічильника і зазначення її початкового значення. <br> - Умова (condition) - вираз, що оцінюється перед 
                       кожною ітерацією (повторенням) циклу. Тіло циклу виконується тільки тоді, коли вираз приводиться до true. Цикл завершується, якщо значення буде false. <br>  Тіло (statements)
                        - набір інструкцій для виконання на кожному повторенні. Виконується, якщо вираз умови приводиться до true. <br> Пост-вираз (post-expression) - виконується в кінці
                         кожного повторення циклу, до перевірки умови. Використовується для оновлення змінної-лічильника.<br><br> Змінні-лічильники, за традицією, називаються літерами i, j і k.</b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for...of"</b><br><br></p></td>
                <td><p>for (const <b>variable</b> of <b>iterable</b>) {<br>  <span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx" ><p></p>Цикл без <u>лічильника</u> - оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки. Тіло циклу буде виконуватися
                     для значення кожного елемента. Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації. Основні визначення циклу for...of:<br><br> - variable —
                      змінна, яка буде зберігати значення елемента на кожній ітерації. <br><br> - iterable — колекція, яка містить ітерабельні (що можна порахувати) елементи, наприклад масив. -  <br>  
                         <br><br></b></u></p></td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "for...in"</b><br><br></p></td>
                <td><p>for (key in object) {<br><span style="color: #f79c41"> код, тіло циклу (statement)</span><br>}</p></td>
                <td class="third-td-tx"><p>Цикл для перебирання ключів об'єкта <b>object</b>. <br>Змінна key доступна тільки в тілі циклу. На кожній ітерації в неї буде записано
                     значення ключа (ім'я) властивості. Для того, щоб отримати значення властивості з таким ключем (ім'ям), використовується синтаксис квадратних дужок: <b>object[key]</b><br><br>
                     Оператор in, який використовується в циклі for...in, не робить різниці між власними та невласними властивостями об'єкта. Ця особливість заважає, оскільки ми завжди хочемо перебрати
                      тільки власні властивості. Для того, щоб дізнатись, чи містить об'єкт власну властивість, використовується метод hasOwnProperty(key), який повертає true або false. Саме через цю особливість 
                      for...in  тепер майже не використовується, замість нього використовують for...of.</p>
                </td>           
            </tr>
            <tr>
                <td class="first-td-tx" ><p><b>Цикл "forEach"</b><br><br></p></td>
                <td><p><span style="color: #1a00dd">[масив]</span>.forEach(function callback(element, index, array) {<br>  <span style="color: #f79c41"> код, тіло циклу (statement)</span><br>});</p></td>
                <td class="third-td-tx"><p>Метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією
                     даних. Цикл: <br><br>- Поелементо перебирає масив. <br> - Викликає колбек-функцію для кожного елемента масиву. <br> - Нічого не повертає. <br><br>Аргументи колбек-функції 
                     - це значення поточного елемента element, його індекс index і власне вихідний масив array. Можна оголошувати тільки необхідні 
                     параметри, найчастіше - це елемент, головне не забувати про їх порядок.</p>
                </td>           
            </tr>
            <tr>
                <td style="text-align: left; padding: 10px;" colspan="3"> Для додаткового керування циклом існує два оператори "break" та "continue": <br><br> "break" - повністю припиняє виконання циклу
                     і передає управління на рядок після його тіла.<br><br> "continue" - перериває не увесь цикл, а тільки виконання поточної ітерації. Його використовують, якщо зрозуміло, що на поточній 
                     ітерації циклу більше немає що робити або взагалі не потрібно нічого робити, і час переходити до наступної ітерації. 
                </td>
            </tr>
            
        </tbody>
    </table>
     

   <br><br><br><br><br><br><br><br><br><br><br><br>  

   


    <a class="arrow" href="#top">
        <svg class="icon" width="20" height="20">
            <use href="./images/symbol-defs.svg#icon-arrow-up"></use>
        </svg><p>наверх</p> 
    </a>
</body>
</html>   

